{% extends 'base.html' %}

{% block content %}
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="/static/js/gazefilter.js"></script>
<script>
    // https://beehiveor.gitlab.io/gazefilter/api.html
    const audio = new Audio("http://www.foxysite.de/StarWars/HAN02.WAV");
    document.addEventListener('DOMContentLoaded', initGazefilter());
    // let canvasBox = document.getElementById('canvasBox')
    let trackingData = false;
    async function initGazefilter(){
        let WASM_URL = '/static/gazefilter.wasm';
        await gazefilter.init(WASM_URL);
        try{
            var calibs = window.localStorage.getItem('calibrations');
            await gazefilter.tracker.setCalibration(JSON.parse(calibs));
            // gazefilter.tracker.toggle();
            // gazefilter.tracker.toggle();

        }catch{
            console.log('loading error')
        }
        await gazefilter.tracker.connect(); 
        let canvas = document.getElementById("tracker-canvas");
        gazefilter.visualizer.setCanvas(canvas);
        gazefilter.visualizer.setListener("filter", render);
        
        document.addEventListener("mousemove", startWeights);

        function startWeights(event){
            gazefilter.tracker.calibrate(
                event.timeStamp,  // relative to performance.timeOrigin
                event.screenX,  // in pixels
                event.screenY,  // in pixels
                1.0  // see note below
            ); 
            document.removeEventListener("mousemove", startWeights)
        }
        // document.getElementById('target').click();

        // gazefilter.tracker.setCalibration(calibs);
        // if (calibs){
            // calibs = JSON.parse(calibs);
            // console.log(calibs); 
            // gazefilter.tracker.setCalibration(calibs);
            // console.log(calibs); 
        // }
        // let training = JSON.parse(window.localStorage.getItem('calibrations'));
        // if (training){
        //     gazefilter.tracker.setCalibration(training);
        // }
        // gazefilter.visualizer.setListener('filter', function(){alert('change')});
        // gazefilter.tracker.add


        function oncalib(response) {
            console.log("calibration error: ", response.errorValue);
        }

        // // enable mouse calibration
        // window.addEventListener("click", onmouseclick);

        gazefilter.tracker.addListener("calib", oncalib);

        gazefilter.tracker.addListener("filter", event => {
            if (!isNaN(event.bestGazePoint()[0])){
                // console.log(event.bestGazePoint())
                var[x,y] = event.bestGazePoint();
                var dot = document.getElementById('dot');
                dot.style.left = x + 'px';
                dot.style.top  = y + 'px';
                if (!trackingData){
                    canvasBox.classList.add('ready');
                    trackingData = true
                }
            }else{
                if (trackingData){
                    canvasBox.classList.remove('ready');
                    trackingData = false
                }
            }
        });
        const target = document.querySelector('.target');

        target.addEventListener('click', function(event) {
                audio.play();
                gazefilter.tracker.calibrate(
                    event.timeStamp,  // relative to performance.timeOrigin
                    event.screenX,  // in pixels
                    event.screenY,  // in pixels
                    1.0  // see note below
                );
                try{
                    var myObject =  gazefilter.tracker.getCalibration();
                    // console.log(myObject)
                    // // myObject.circular = myObject; // Create a circular reference
                    // const serialized = customSerialize(myObject);
                    // window.localStorage.setItem('calibrations',serialized);
                    var calibs = new Object;
                    calibs.count = myObject.count;
                    calibs.data = Array.from(myObject.data); // bug fix
                    calibs.device = myObject.device;
                    calibs.error = myObject.error;
                    calibs.eye = myObject.eye;
                    calibs.timestamp = myObject.timestamp;
                    calibs.version = myObject.version;
                    window.localStorage.setItem('calibrations', JSON.stringify(calibs));
                    // gazefilter.tracker.setCalibration(JSON.parse(JSON.stringify(calibs)))
                }catch{}
                transportTarget(target);
        });

    }

    function transportTarget(target){
        const x = Math.floor(Math.random() * (window.innerWidth - 50));
        const y = Math.floor(Math.random() * (window.innerHeight-50));
        target.style.left = x + 'px';
        target.style.top = y + 'px';
    }
    function render(ctx, trackEvent) {
        console.log('drW')
        // draw video frame
        ctx.drawImage(
            gazefilter.tracker.videoElement(),
            0, 0, ctx.canvas.width, ctx.canvas.height
        );

        // set drawing style
        ctx.strokeStyle = 'white';
        ctx.fillStyle = 'white';
        ctx.lineWidth = 2;

        // draw facial landmarks
        let shapeArray = trackEvent.shapeArrayView();
        for (let i = 0; i < trackEvent.shapeSize(); i++) {
            ctx.beginPath();
            let pointX = shapeArray[i * 2];
            let pointY = shapeArray[i * 2 + 1];
            ctx.arc(pointX, pointY, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // draw pupil center points
        ctx.strokeStyle = 'red';
        let [lx, ly, rx, ry] = trackEvent.pupilArray();
        ctx.beginPath();
        ctx.arc(lx, ly, 3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(rx, ry, 3, 0, Math.PI * 2);
        ctx.stroke();
    }

    // function initTrain(){
        //if theres data
        //else
        // try{
            // console.log(gazefilter.tracker.getCalibration())
        // }catch{
            // console.log('not conntected')
        // }
    // }
</script>
<canvas style="width: 256px !important; height: 192px !important; transform: rotateY(180deg) !important;" id="tracker-canvas"></canvas>
<div id="canvasBox"></div>
<div id="dot" style="position: absolute; left: 0; top:0; width:15px; height: 15px; border-radius: 50%; background-color: red;"></div>
<div id="target" class="target">
    <div class="bullseye"></div>
</div>

<style>
    .target {
        width: 40px;
        height: 40px;
        background-color: #fff;
        border: 10px solid #f00;
        border-radius: 50%;
        position: absolute;
        left:300px;
        top:500px;
        z-index: 999999999999999999999999999999999999999999999999999;
        caret-color: rgb(0, 255, 17)
    }

    .bullseye {
        width: 20px;
        height: 20px;
        background-color: #f00;
        border-radius: 50%;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

    body{
        cursor: crosshair;
        height: 100vh;
    }

</style>
  

{% endblock content %}